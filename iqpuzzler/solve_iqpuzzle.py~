import numpy as np
import itertools

# the class for a single piece, its name and shape
class Piece:
  def __init__(self, id, shortname, data):
    self.id = id
    self.shortname = shortname
    self.data = data

  def size():
    return shape.sum()


p_pink =    Piece(11, "Pink",  np.array([[1,1,1,0],[0,0,1,1]]))
p_mblue =   Piece(22, "MBlu",  np.array([[1,1,1],[0,0,1],[0,0,1]]))
p_lblue =   Piece(33, "LBlu",  np.array([[1,0],[1,1]]))
p_dblue =   Piece(44, "DBlu",  np.array([[1,1],[0,1],[0,1]]))
p_lgreen =  Piece(55, "LGrn",  np.array([[1,1],[1,1],[0,1]]))
p_dgreen =  Piece(66, "DGrn",  np.array([[0,1,0],[1,1,1]]))
p_lred =    Piece(77, "LRed",  np.array([[1,1],[0,1],[0,1],[0,1]]))
p_dred =    Piece(88, "DRed",  np.array([[0,1,1],[1,1,0]]))
p_yellow =  Piece(911, "Yelw", np.array([[1,1,1,1],[0,1,0,0]]))
p_orange =  Piece(922, "Orng", np.array([[0,0,1],[1,1,1],[0,1,0]]))
p_purple =  Piece(933, "Purp", np.array([[1,1,0],[0,1,1],[0,0,1]]))
p_olive =   Piece(944, "Oliv", np.array([[1,0,1],[1,1,1]]))

steps = 0


# overlay a small matrix on top of a big one, at (row,col)
def overlay(big, row, col, small):
  big[row:row+small.shape[0], col:col+small.shape[1]] = small
  return big


# use a bfs way to fill hole at [i,j]
def fill_hole(b, row, col):
  q = [(row,col)]
  while len(q) > 0:
    # dequeue and fill
    (i, j) = q[0]
    q = q[1:]
    b[i,j] = 1

    # add other parts
    if b[i-1,j] == 0:
      q += [(i-1, j)]
    if b[i+1,j] == 0:
      q += [(i+1, j)]
    if b[i,j-1] == 0:
      q += [(i, j-1)]
    if b[i,j+1] == 0:
      q += [(i, j+1)]

# return the number of "holes" in the code
def has_invalid_shape(board):
  clipped = board.clip(0,1)

  b = overlay(np.zeros((7,13), dtype=np.int), 1,1,clipped)
  rows = b.shape[0]
  cols = b.shape[1]
  holes = 0
  while (True):
    found = False
    for i in range(rows):
      for j in range(cols):
        if b[i,j] == 0:
          #found a hole, try to fill it
          fill_hole(b, i, j)
          hole += 1
    if not found:
      break
  return holes



# add a piece at row/col, 0-based
# returns a new version of board, if invalid, returns None
def add_piece(board, piece, row, col, transpose = False, fliplr = False, flipud = False):
  # make into right form
  p = piece.data.transpose() if transpose else piece.data
  p = np.fliplr(p) if fliplr else p  
  p = np.flipud(p) if flipud else p  

  placement = ("(%2d, %2d) %9s %9s %9s" %
    (row, col,
     "Transpose" if transpose else "",
     "flip LR" if fliplr else "",
     "flip UD" if flipud else ""))

  # check if the piece will go out of board boundary
  if ((row + p.shape[0] > board.shape[0]) or (col + p.shape[1] > board.shape[1])):
    # print("%s : %s : rejected for out of boundary" % (placement, piece.shortname))
    return None

  # embed this piece into an empty board
  piece_big = np.zeros((5,11), dtype=np.int)
  piece_big[row:row+p.shape[0], col:col+p.shape[1]] = p * piece.id  # store id in pic

  # check for overlap
  if (board * piece_big).sum() > 0:
    # print("%s : %s : rejected for overlapping with existing" % (placement, piece.shortname))
    return None

  # quick invalidation for some obviously not working case, like "eyes" with only 1-2 cells
  tmp = board + piece_big
  if has_invalid_shape(tmp):
    return None

  # valid position, add this piece to the board and return
  return board + piece_big


def pretty_print(board):
  for i in range(5):
    print(" ".join("%4d" % x for x in list(board[i])))
  print()


def pretty_stack(stack):
  results = []
  for i in range(len(stack)):
    (dummy, pos) = stack[i]
    p = pieces[i]
    results += ["[%5s] p%3d" % (p.id, pos)]
  print(" ".join(results))


# search for solutions in DFS manner
def search_for_solutions(start_board, pieces):
  s = start_board.sum() + sum([p.data.sum() for p in pieces])
  if not s == 11*5:
    print("CANNOT SOLVE, invalid start, sum = %d (should be 55)" % s)
    exit()

  # generate all positions and orientations each piece can be tried with
  tf = [False, True]
  all_args = list(itertools.product(tf, tf, tf))
  all_pos = list(itertools.product(all_args, list(range(5)), list(range(11))))

  print("Total positions to explore for each piece: %d" % len(all_pos))
  print("Total pieces remaining: %d" % len(pieces))

  status_stack = []
  cur_board = start_board
  cur_pos_index = 0
  p = pieces[0]

  while(True): 

    #print("-- dealing with %5s, start pos_index = %d" % (p.shortname, cur_pos_index))

    while cur_pos_index < len(all_pos):
      ((trans, fliplr, flipud), row, col) = all_pos[cur_pos_index] 
      board = add_piece(cur_board, p, row, col, trans, fliplr, flipud)

      # --- check for success ---
      if board is not None:
        if board.min() > 0:
          print("-- FOUND SOLUTION!! --")
          pretty_print(board)
          exit()
        else:
          # -------- still more space to fill --------
          '''
          print("PUSH: %5s at (%d, %d) %s%s%s   (pos_index = %d)  stack len afterwards = %d" %
           (p.shortname, row, col,
            "T " if trans else "- ",
            "LR " if fliplr else "-  ",
            "UD " if flipud else "-  ",
            cur_pos_index,
            len(status_stack) + 1))
          '''
   
          status_stack += [(cur_board, cur_pos_index)]  # old board in it
          pretty_stack(status_stack)
          #pretty_print(board)

          # start the placement for a new piece
          cur_board = board
          cur_pos_index = 0
          p = pieces[len(status_stack)]

      else:
        # the piece cannot be added with this position config
        cur_pos_index += 1
    # end of inner while

    # keep popping until we have some pos available to try
    #print("  -- running out of pos for %s, current stack len = %d" % (p.shortname, len(status_stack)))

    while(cur_pos_index == len(all_pos)):
      p = pieces[len(status_stack) - 1]  # record last one for display purpose

      #print("POP : %5s" % (p.shortname))
      (cur_board, cur_pos_index) = status_stack[-1]
      status_stack = status_stack[:-1]   # actually pop
      cur_pos_index += 1

  # end of outer while
    
    
if __name__ == "__main__":

  # ---- set the value of start and pieces to a game ----
  # problem 34 of IQ Puzzler Pro

  start = np.array([
    [1,1,1,1,1,1,1,0,0,0,0],
    [0,0,1,0,0,1,1,0,0,0,0],
    [0,0,0,0,0,1,1,0,0,0,0],
    [0,0,0,0,0,1,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0]
  ])

  # 12 in total, comment out the ones already used
  pieces = [
    p_pink,
    p_yellow,
    p_orange,
    p_purple,
    p_olive,
    p_mblue,
    p_lblue,
    # p_dblue,
    # p_lgreen,
    p_dgreen,
    # p_lred,
    p_dred
  ]

  search_for_solutions(start, pieces)


